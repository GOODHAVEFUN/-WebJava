day12

복습 -> 테스트(60분) -> 예외처리

0. 총복습
.java 기본구조
	java 프로젝트 -> 패키지 -> 클래스 -> 메소드 ->소스코드
	
클래스 기본구조
	필드, 생성자, 메소드

출력메소드
	print() 
	println()
	printf()
	
입력메소드
	next()
	nextLine()
	nextInt()
	nextDouble()
	
제어문자
	\n , \t, \", \', \\
	
변수명(카멜케이스)
	변수		값을 저장할수 있는 저장공간
	변수명	저장공간의 이름
	
자료형
기본자료형		정수		int, long
			실수		double, float
			논리		boolean
			문자형	char
참조자료형		문자열	String

형변환
	강제형변환(명시적 형변환), 자동형변환(묵시적 형변환)
	문자열 -> 다른 자료형	Integer.parseInt("문자열")
						"문자열".charAt(0)		=>문자열
	다른 자료형 -> 문자열	3  + "번" =>
	
연산자 우선순위 
		최우선
		단항
		산술
		쉬프트
		관계
		리
		삼
		대
제어문
	조건문	if, switch
	반복문	for, while, do~while
	기타제어문 break, continue
	
배열
		저장공간의 나열
		
			1) 저장공간 여러개를 하나의 이름으로 관리할 수 있음
			2)규칙성이 없는 값에 규칙성을 부여할 수 있음(index)
			3) 하나의 타입으로 된 여러개의 값을 저장할 수 있음
		
배열의 선언
		-어떤값을 넣을 지 알 때
		자료형[] 배열명 = {값, 값}
		-어떤값을 넣을지 모르지만 몇칸이 필요한지는 알떄
		자료형[] 배열명 = new 자료형[칸 수];
		-어떤 값을 넣을지도 모르고 몇칸이 필요한지도 모를때
		자료형[] 배열명 = null;
	
2차원 배열의 선언
		자료형[][] 배열명 = {{},{}}
		자료형[][] 배열명 = new 자료형[행][열];
2차원 배열의 길이
		배열명.length			: 행의 길이
		배열명[행].length		: 열의 길이
	
메소드
		기능
		1)재사용
		2)가독성
		3)모듈화
		
클래스
		1) 연관성이 있는 타입과 여러개의 기능을 한 곳에 모아 관리할 수 있다
		2) 타입이다
		3)객채를 생성하기위한 틀

객체화		
		객체를 만드는 작업
		클래스명 참조변수 = new 생성자();
		
생성자
		필드 초기화

기본생성자
		컴파일러가 클래스를 컴파일 할 때 자동으로 생성되는 것(JDK의 javac 컴파일러가 담당)

JVM, JRE, JDK
	JVM(Java Virtual Machine)
			Java코드를 기계어로 변환, 메모리 관리, 가비지컬랙션, 쓰래드 관리 기능 담당
			
	JRE(Java Runtime Environment)
			Java 프로그램을 실행하기 위해 필요한 런타임 환경을 제공
			JVM과 필요한 라이브러리 등이 포함 되어 있음
	JDK(Java Development Kit)
		java 개발에 필요한 컴파일러(javac), 디버거(jdb), 문서화도구(javadoc) 등
		도구를 포함하고 있음
		
		
.java -javac 파일명.java--> .class ----java파일명 ---> 실행결과

다향성(Polymorphism) 	하나의 객체가 여러가지 타입으로 동작할 수 있는 것 
					코드의 유연성, 재사용성
		
		오버로딩 			생성자, 메소드
		오버라이딩			메소드
		참조변수의 다향성	상속(부모 클래스 타입의 참조변수로 하위 클래스 객체 참조)
		
this, this()
		this	객체 자기자신, 
				객체의 주소값을 this라는 변수에 담을수 있으며 자동으로 담긴다
				this.필드명 = 매개변수 //생성자	
				일반적으로 생성자의 매개변수와 클래스의 필드 이름이 중복될 경우 구분하기 위해 사용한다
		this()	자기 자신의 생성자
				생성자 내부에서만 사용가능하며 최상단에 작성한다
				
변수의 종류
		지역변수 클래스 중괄호 영역은 포함되지 않고, 메소드나 그 안에서 선언된 변수
		매개변수 메소드의 소괄호 안에서 선언되는 변수
		전역변수 클래스 중괄호 영역에서 선언되는 변수
		
		
상속(Inheritance)
		1)재사용
		2)그룹화
		
super, super()
		super	부모의 참조값
		super()	부모의 생성자
		
casting
		up casting		자식 값을 부모 타입으로 형변환
						다양한 타입을 한번에 관리하기 위해서
		down casting	up casting 된 객체를 자식 타입으로 형변환
						up casting 된 객체를 자식 타입으로 형변환						
						* 부모의 값을 자식 타입으로 형변환시 오류 발생
						
객체 간 타입 비교
		a instanceof A a가 A타입이면		
		
접근권한제어자
		default:
		public:
		protected:자식클래스
		private:다른클래스에서 접근 불가, 메소드			

추상클래스
		추상메소드가 1개 이상 있는 클래스
		abstract
		멤버 : 필드,추상메소드, 일반메소드
		
사용 이유
		강제성을 부여하기 위해
		개발자가 재정의를 안하고 그냥 사용할수 있다는 실수를 방지하기 위해
		
인터페이스
		interface 인터페이스명{
				//상수 public static final, 추상메소드 public abstract
				//default, static, private
		}
사용이유
		1) 표준화
		2) 그룹화(마커 인터페이스)
		
Adapter 클래스
		인터페이스의 강제성을 어뎁터클래스를 통헤 없에주고 자식클래스에서 상속받아
		필요한 메소드만 재정의 하여 사용한다
다중구현 
		Implement 인터페이스명1, 인터페이스명2
단일상속
		extends 클래스명1
		
모호성(ambiguity)
		하나의 자식이 여러부모를 상속받을 때 부모 필드에 동일한 이름의 필드가 있다면
		어떤 부모의 필드인지 알 수 없는것
		
해결방안
		1)두개의 인터페이스 내에 같은 이름과 매개변수의 메소드가 선언되
		
마커 인터페이스(Maker Interface)
		클래스들을 그룹화하기 위한 목적으로 사용한다
		인터페이스는 지정한 클래스의 부모이며, 모든 자식은 부모의
		
내부클래스(Inner Class)
		클래스 내부에 선언된 클래스
		외부클래스 : 내부클래스를 가진 클래스
		
		메소드 안에서 클래스를 선언할 수 있다
		내부클래스로 선언된 클래스는 외부 클래스를 상속받지 않아도 외부 클래스의 멤버를 사용할 수 있다
		외부클래스가 메모리에 할당되어야 내부
		
익명 클래스(Anonymouse inner class)
		이름이 없는 클래스
		미구현된 멤버를 구현하여 일회성으로 객체를 생성하기 위해 사용한다
		
		ClassA ca = new ClassA(){
				//오버라이딩
		};
		// 주소값이기떄문에 끝에 ; 을 붙여준다
		
람다식(Lambda Expression) : 익명메소드
		함수형 인터페이스 : 단 하나의 추상메소드를 가지고 있는 인터페이스
					@FunctionalInterface
		
		라다식을 사용할 떄는 람다식을 저장하기 위한 참조 변수의 타입을 결정해야한다
		람다식을 하나의 변수에 대입할 때 사용하는 참조변수의 타입을 함수형 인터페이스라고 부른다

람다식 문법
		
		
일반메소드
		리턴타입 메소드명(자료형 매개변수){
			실행할 문장1;
			실행할 문장2;
			return 리턴값;
		}
		
		매개변수명 -> {실행할 문장1;실행할문장2;return 리턴값}
		
		(자료형 매개변수명1, 매개변수명2) {
			실행할문장1;
		}
		
		(매개변수명1, 매개변수명2)
		
		